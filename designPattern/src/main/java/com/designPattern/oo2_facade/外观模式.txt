外观模式（门面模式）:
优点:
1:松散耦合
	外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。
2:简单易用
	外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就可以了，
	相当于外观类为外部客户端使用子系统提供了一站式服务。
3:更好地划分访问的层次
	Facade的方法实现中，一般是负责把客户端的请求转发给子系统内部的各个模块进行处理，
	Facade的方法本身并不进行功能的处理，Facade的方法实现只是实现一个功能的组合调用。
	
本质:封装交互，简化调用

何时使用外观模式:
1:如果你希望为一个复杂的子系统提供一个简单接口的时候，可以考虑使用外观模式。使用外观对象来实现大部分客户需要的功能，从而简化客户的使用
2:如果想要让客户程序和抽象类的实现部分松散耦合，可以考虑使用外观模式，使用外观对象来将这个子系统与它的客户分离开来，从而提高子系统的独立性和可移植性
3:如果构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，这样可以简化层间调用，也可以松散层次之间的依赖关系


外观模式与单例模式:
	通常一个子系统只需要一个外观实例，所以外观模式可以和单例模式组合使用，把Facade类实现成为单例。
当然，也可以跟前面示例的那样，把外观类的构造方法私有化，然后把提供给客户端的方法实现成为静态的。

外观模式和抽象工厂模式:
	外观模式的外观类通常需要和系统内部的多个模块交互，每个模块一般都有自己的接口，所以在外观类的具体实现里面，需要获取这些接口，
然后组合这些接口来完成客户端的功能。那么怎么获取这些接口呢?
	就可以和抽象工厂一起使用，外观类通过抽象工厂来获取所需要的接口，而抽象工厂也可以把模块内部的实现对Facade进行屏蔽，
也就是说Facade也仅仅只是知道它从模块中获取它需要的功能，模块内部的细节Facade也不知道。

